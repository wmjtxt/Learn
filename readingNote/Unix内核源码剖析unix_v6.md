Unix内核源码剖析 青柳隆宏
====

# 1.Unix V6
Unix V6, 1975, 贝尔实验室; PDP-11


* 基本功能
    * 管理运行中的程序（进程）
    * 内存管理
    * 文件系统
    * 文件和周边设备共享I/O
    * 中断
    * 支持终端处理

* PDP-11
    * PSW(Processor Status Word): 处理器状态字，16位
|比特位|含义|
|15~14|处理器当前模式(00:内核模式,11:用户模式)|
|13~12|处理器先前模式(00:内核模式,11:用户模式)|
|7-5|处理器优先级（7~0）|
|4|陷入（trap）位|
|3|N。负位。指令执行结果为负时置1|
|2|Z。零位。指令执行结果为0时置1|
|1|V。溢出位。指令执行中发生溢出时置1|
|0|C。借位位。指令执行中发生进位或借位时置1|

# 2.进程

## 2.1 进程的概要
* 进程的状态: 可执行状态，休眠状态
* 处理器具有两种模式：用户模式和内核模式，通过PSW能够在两者间切换 
* 切换模式时，映射到虚拟地址空间的物理内存区域也随之发生变换。
* 进程的状态信息和控制信息由proc结构体和user结构体管理。每个进程都包含一组proc和user结构体

## 2.2 进程的proc结构体和user结构体

### proc结构体

* proc结构体常驻内存。
* proc结构体管理着在进程状态、执行优先级等与进程相关的信息中需要经常被内核访问的那部分信息。
```c
struct proc
{
    char p_stat;
    char p_flag;
    char p_pri;
    char p_sig;
    char p_uid;
    char p_time;
    char p_cpu;
    char p_nice;
    char p_ttyp;
    char p_pid;
    char p_ppid;
    char p_addr;
    char p_size;
    char p_wchan;
    char *p_textp;
}proc[NPROC];
/* stat codes */
#define SSLEEP  1
#define SWAIT   1
#define SRUN    1
#define SIDL    1
#define SZOMB   1

/* flag codes */
#define SLOAD   01
#define SSYS    02
#define SLOCK   04
#define SSWAP   010
#define STRC    020
#define SWTED   040
```
表2-1 proc结构体
|成员|含义|
|-|-|
|p_stat|状态。等于NULL时意味着proc[]数组中该元素为空。|
|p_flag|标志变量。参见表2-3|
|p_pri|执行优先级。数值越小优先级越高，下次被执行的可能性也就越大|
|p_sig|接收到的信号|
|p_uid|用户ID(整数)|
|p_time|在内存或交换空间内存在的时间(秒)|
|p_cpu|占用CPU的累计时间（时钟tick数）|
|p_nice|用来降低执行优先级的补正系数。缺省值是0，通过系统调用nice可以设置成用户希望的数值|
|p_ttyp|正在操作进程的终端|
|p_pid|进程ID|
|p_ppid|父进程ID|
|p_addr|数据段的物理地址(单位为64字节)|
|p_size|数据段的长度（单位为64字节）|
|p_wchan|使进程进入休眠状态的原因|
|\*p_textp|使用的代码段（text segment）|
表2-2 进程的状态
|状态|含义|
|-|-|
|SSLEEP|高优先级休眠状态。执行优先级为负值|
|SWAIT|低优先级休眠状态。执行优先级为0或正值|
|SRUN|可执行状态|
|SIDL|进程生成中|
|SZOMB|僵尸状态|
|SSTOP|等待被跟踪|
表2-3 进程的标志常量
|SLOAD|进程图像处于内存中（未被换出至交换空间）|
|SSYS|系统进程，不会被换出至交换空间。在UNIX V6中只有proc[0]是系统进程|
|SLOCK|进程调度锁。不允许进程图像被换出至交换空间|
|SSWAP|进程图像已被换出至交换空间。由于被换出至交换空间，user.u_rsav[]的值不再有效。必须从user.u_ssav[]中恢复r5、r6的值|
|STRC|处于被跟踪状态|
|SWTED|在被跟踪时使用|

### user结构体
* user结构体有可能被移交至交换空间
* user结构体用来管理进程打开的文件或目录信息。
* 内核只需要当前进程的user结构体，因此当进程被换出至交换空间时，对应的user结构体也会被移出内存。

代码清单2-3 user结构体（user.h）
```c
struct user
{
    int u_rsav[2];
    int u_fsav[25];
    char u_segflg;
    char u_error;
    ...
};
```

## 2.3 为进程分配的内存

### 代码段
代码段是只读的，用来存放作为程序指令的机器代码。某个程序在被同时执行多次时，各进程共享同一个代码段。代码段通过数组text[]进行管理，长度由user.u_tsize表示。

### 数据段
数据段用来存放程序使用的变量等数据。数据段不会被多个进程共享。
* PPDA(Per Process Data Area)
    * user结构体和内核栈区域构成
    * 长度为USIZE * 64字节 = 1KB。从用户空间无法访问
    * 内核栈区域被用作内核处理时的临时工作区域。每个进程都具有提供内核模式使用的工作区域。
* 数据区域
由存放全局变量或bss等静态变量的区域和进程用来动态管理内存的堆区域构成。
扩展堆区域需要通过系统调用来完成。扩展从虚拟地址的低位向高位方向进行，长度由user.u_dsize表示。
* 栈区域
用来暂时存放函数的参数或局部数据。长度根据需要自动扩展。栈区域的扩展从虚拟地址的最高位向低位方向进行，长度由user.u_ssize表示。

### 虚拟地址空间
* 进程有64KB的虚拟地址空间，通过长度为16比特的虚拟地址访问物理内存。虚拟地址由MMU转换成长度为18比特的物理地址。
* 每个进程都拥有自己的虚拟地址空间

# 3.进程的管理

## 3.1 进程的生命周期

* 1.某个进程通过系统调用fork,创建一个用于执行程序的进程。生成此进程的进程称为父进程，被生成的进程称为子进程。子进程通过复制父进程的数据得以创建。
* 2.父进程执行系统调用wait,进入等待状态直到子进程处理结束。
* 3.当控制权转移到子进程后，子进程通过系统调用exec将程序读取到内存并开始执行。
* 4.当程序执行完毕后，子进程通过系统调用exit结束自身的运行状态进入僵尸状态，控制权交回给父进程。
* 5.父进程得到子进程的执行结果后清理子进程。

以下代码是用C语言编写的进行上述处理的例子。C语言的函数库提供了用来包装系统调用的函数，使用户程序可以像执行普通函数那样访问系统的调用。
```c
1 i = fork();
2 if(i == 0){
3     execv(program_name, argv);
4     exit();
5 }
6 while(wait() != i)
```
* 1 执行fork()将生成一个进程。父进程通过fork()得到子进程的ID.
* 6 执行wait()进入等待状态直至子进程处理结束。父进程进入休眠状态，
（如果此时不存在其他执行优先级更高的进程）控制权将被转交给子进程。
* 1 子进程从fork()内部开始进行自身的处理，并从fork()返回0；
* 3 在程序最后，执行由编译器插入的用以访问系统调用exit的指令以终止进程。
* 4 此处加入exit()是为了防止execv()执行失败。
* 6 控制权被交回父进程。通过wait()返回已结束的子进程ID。


## 3.2 创建进程

### 进程的复制

通过将父进程的数据复制到子进程，以此创建新的进程。

**被复制的数据:**
* 复制proc[]数组元素
    * 子进程的proc.p_ppid指向父进程的proc.p_pid.
* 复制数据段
    * 复制对象包括PPDA。子进程继承了已打开的文件和当前目录等数据。
    * 子进程的user.p_procp指向proc[]中代表子进程的元素。
    * 代码段不是复制对象。子进程与父进程共享text[]中的相同元素。text[]用来管理代码段,详细请参考第4章。

### 父进程与子进程
父进程和子进程具有如下特点：
* 各进程拥有1个父进程和0个以上的子进程
* 父进程在子进程结束时，取其结束状态并释放子进程资源
* 子进程继承了父进程打开的文件和当前目录等数据
* 子进程和父进程共享代码段。但是，如果子进程执行了其他程序，这种共享关系将被解除。
* 由于子进程和父进程各自独立，因此他们拥有独立的数据段，user结构体和proc[]数组元素。在执行时不会相互影响。

Unix V6提供了使父进程可以介入子进程处理的跟踪机制，以及用于实现父子进程间通信的管道机制。

### 系统调用fork
