C++ Primer 5th
====

# 目录
* [#IC++基础](#IC++基础)
* [## 2 变量和基本类型](##2.变量和基本类型)
    * [2.3.1引用](###2.3.1引用)
    * [2.3.2指针](###2.3.2指针)
    * [2.4.1const的引用](###2.4.1const的引用)
    * [2.4.2指针和const](###2.4.2指针和const)
    * [2.4.4constexpr和常量表达式](###2.4.4constexpr和常量表达式)
    * [2.5.2auto](###2.5.2auto)
    * [2.5.3 decltype](###2.5.3decltype)

# I.C++基础

## 2.变量和基本类型

### 2.3.1引用

* C++11中新增的"右值引用",主要用于内置类. 我们常用的术语"引用",指的是"左值引用".
* 引用必须被初始化
* 引用一旦初始化,将和初始值绑定在一起,无法重新绑定到另一个对象.
引用只能绑定到对象上,不能与字面值或某个表达式的结果绑定到一起
* 引用只是一个别名,并非对象,所以不能定义引用的引用

### 2.3.2指针

* 指针是指向另外一种类型的复合类型.
* 指针本身是一个对象
* 指针无须在定义时赋初值
* 因为引用不是对象,没有实际地址,所以不能定义指向引用的指针

### 2.4.1const的引用

* 把引用绑定到const对象上,称为**对常量的引用**(reference to const)
* 对常量的引用不能被用做修改它所绑定的对象.
* 当对const的引用绑定一个非const的对象时,可以通过其他途径改变该对象的值.


### 2.4.2指针和const

* 顶层const: 指针本身是个常量
* 底层const: 指针所指的对象是个常量

```c
int i = 0;
int *const p1 = &i;         //不能改变p1的值,这是一个顶层const
const int ci = 42;          //不能改变ci的值,这是一个顶层const
const int *p2 = &ci;        //允许改变p2的值,这是一个底层const
const int *const p3 = p2;   //靠右的是顶层const,靠左的是底层const
const int &r = ci;          //用于声明引用的const都是底层const
```
* 当执行对象的拷贝操作时,顶层const不受什么影响,底层const的限制不能忽视:
当执行对象的拷贝操作时,拷入和拷出的的对象必须具有相同的底层const资格,或者两个对象的数据类型必须能够转换.
一般来说,非常量可以转换成常量,反之则不行.

### 2.4.4constexpr和常量表达式

### 2.5.2auto

### 2.5.3 decltype
* 如果表达式是解引用操作,则decltype将得到引用类型.
* decltype的表达式如果是加上括号了的变量,结果将是引用

